/**
 * TrackPiece.ts - Represents a placed track piece in the layout
 * 
 * Each piece has:
 * - A catalog type reference
 * - World transform (position + rotation)
 * - Connectors (with computed world positions)
 * - Associated graph nodes and edges
 * - Switch state (for switch pieces)
 * 
 * @module TrackPiece
 */

import { Vector3, Quaternion, Matrix } from '@babylonjs/core/Maths/math.vector';
import type { TrackCatalogEntry } from './TrackCatalog';

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

/**
 * A connector point on a track piece
 */
export interface Connector {
    /** Unique identifier for this connector (e.g., 'A', 'B', 'COMMON') */
    id: string;
    /** Position relative to piece center */
    localPos: Vector3;
    /** Direction track exits this connector (local space) */
    localForward: Vector3;
    /** Computed world position */
    worldPos?: Vector3;
    /** Computed world direction */
    worldForward?: Vector3;
    /** Associated graph node ID */
    nodeId?: string;
}

/**
 * Transform data for a track piece
 */
export interface Transform {
    /** World position */
    position: Vector3;
    /** World rotation */
    rotation: Quaternion;
}

// ============================================================================
// TRACK PIECE CLASS
// ============================================================================

/**
 * TrackPiece - A placed instance of a track catalog entry
 * 
 * Manages the relationship between catalog definition, world placement,
 * and graph connectivity.
 * 
 * @example
 * ```typescript
 * const piece = new TrackPiece('p1', catalogEntry, position, rotation);
 * const connectorA = piece.getConnector('A');
 * ```
 */
export class TrackPiece {
    /** Unique piece identifier */
    id: string;

    /** Reference to catalog entry ID */
    catalogId: string;

    /** Full catalog entry data */
    catalogEntry: TrackCatalogEntry;

    /** World transform */
    transform: Transform;

    /** Connection points */
    connectors: Connector[];

    /** IDs of graph edges generated by this piece */
    generatedEdgeIds: string[] = [];

    // ========================================================================
    // SWITCH-SPECIFIC PROPERTIES
    // ========================================================================

    /** Whether this piece is a switch/turnout */
    isSwitch: boolean;

    /** Current switch state: 'A' = straight, 'B' = diverging */
    switchState?: 'A' | 'B';

    // ========================================================================
    // CONSTRUCTOR
    // ========================================================================

    /**
     * Create a new track piece
     * @param id - Unique identifier
     * @param catalogEntry - Track catalog entry defining this piece type
     * @param position - World position
     * @param rotation - World rotation
     */
    constructor(
        id: string,
        catalogEntry: TrackCatalogEntry,
        position: Vector3,
        rotation: Quaternion
    ) {
        // Validate inputs
        if (!id) throw new Error('[TrackPiece] id is required');
        if (!catalogEntry) throw new Error('[TrackPiece] catalogEntry is required');
        if (!position) throw new Error('[TrackPiece] position is required');
        if (!rotation) throw new Error('[TrackPiece] rotation is required');

        this.id = id;
        this.catalogId = catalogEntry.id;
        this.catalogEntry = catalogEntry;
        this.transform = {
            position: position.clone(),
            rotation: rotation.clone()
        };

        // Determine if this is a switch piece (includes curved switches)
        this.isSwitch = catalogEntry.type === 'switch' || catalogEntry.type === 'curved_switch';
        if (this.isSwitch) {
            this.switchState = 'A'; // Default to inner/straight route
        }

        // Create connectors from catalog templates
        this.connectors = catalogEntry.connectorTemplates.map(template => ({
            id: template.id,
            localPos: template.localPos.clone(),
            localForward: template.localForward.clone()
        }));

        // Compute initial world transforms
        this.updateWorldTransforms();

        console.log(`[TrackPiece] Created ${id} (${catalogEntry.name})`);
    }

    // ========================================================================
    // TRANSFORM MANAGEMENT
    // ========================================================================

    /**
     * Update world positions and directions for all connectors
     * Call this after changing position or rotation
     */
    updateWorldTransforms(): void {
        try {
            // Build transformation matrix from position and rotation
            const matrix = Matrix.Compose(
                Vector3.One(),           // Scale (uniform)
                this.transform.rotation,  // Rotation
                this.transform.position   // Translation
            );

            // Transform each connector
            this.connectors.forEach(connector => {
                // Transform local position to world space
                connector.worldPos = Vector3.TransformCoordinates(
                    connector.localPos,
                    matrix
                );

                // Transform local direction to world space (rotation only)
                connector.worldForward = Vector3.TransformNormal(
                    connector.localForward,
                    matrix
                );
                connector.worldForward.normalize();
            });

        } catch (error) {
            console.error(`[TrackPiece] Error updating transforms for ${this.id}:`, error);
        }
    }

    /**
     * Set piece position and update transforms
     * @param position - New world position
     */
    setPosition(position: Vector3): void {
        if (!position) {
            console.error('[TrackPiece] setPosition: position is required');
            return;
        }
        this.transform.position = position.clone();
        this.updateWorldTransforms();
    }

    /**
     * Set piece rotation and update transforms
     * @param rotation - New world rotation
     */
    setRotation(rotation: Quaternion): void {
        if (!rotation) {
            console.error('[TrackPiece] setRotation: rotation is required');
            return;
        }
        this.transform.rotation = rotation.clone();
        this.updateWorldTransforms();
    }

    /**
     * Set both position and rotation at once
     * @param position - New world position
     * @param rotation - New world rotation
     */
    setTransform(position: Vector3, rotation: Quaternion): void {
        if (!position || !rotation) {
            console.error('[TrackPiece] setTransform: position and rotation are required');
            return;
        }
        this.transform.position = position.clone();
        this.transform.rotation = rotation.clone();
        this.updateWorldTransforms();
    }

    // ========================================================================
    // CONNECTOR ACCESS
    // ========================================================================

    /**
     * Get a connector by ID
     * @param id - Connector ID to find
     * @returns Connector or undefined if not found
     */
    getConnector(id: string): Connector | undefined {
        return this.connectors.find(c => c.id === id);
    }

    /**
     * Get all connectors that don't have an associated graph node
     * @returns Array of unconnected connectors
     */
    getUnconnectedConnectors(): Connector[] {
        return this.connectors.filter(c => !c.nodeId);
    }

    /**
     * Get all connectors that have an associated graph node
     * @returns Array of connected connectors
     */
    getConnectedConnectors(): Connector[] {
        return this.connectors.filter(c => c.nodeId !== undefined);
    }

    // ========================================================================
    // SWITCH OPERATIONS
    // ========================================================================

    /**
     * Toggle switch state between A (straight) and B (diverging)
     * Only affects switch pieces
     */
    toggleSwitch(): void {
        if (!this.isSwitch) {
            console.warn(`[TrackPiece] ${this.id} is not a switch`);
            return;
        }
        this.switchState = this.switchState === 'A' ? 'B' : 'A';
        console.log(`[TrackPiece] Switch ${this.id} â†’ ${this.switchState}`);
    }

    /**
     * Set switch state explicitly
     * @param state - 'A' for straight, 'B' for diverging
     */
    setSwitchState(state: 'A' | 'B'): void {
        if (!this.isSwitch) {
            console.warn(`[TrackPiece] ${this.id} is not a switch`);
            return;
        }
        this.switchState = state;
    }

    /**
     * Get the active output connector based on current switch state
     * @returns Active output connector or undefined
     */
    getActiveSwitchOutput(): Connector | undefined {
        if (!this.isSwitch) return undefined;

        // For switches: COMMON is input, STRAIGHT and DIVERGING are outputs
        if (this.switchState === 'A') {
            return this.getConnector('STRAIGHT');
        } else {
            return this.getConnector('DIVERGING');
        }
    }

    /**
     * Get the inactive output connector based on current switch state
     * @returns Inactive output connector or undefined
     */
    getInactiveSwitchOutput(): Connector | undefined {
        if (!this.isSwitch) return undefined;

        if (this.switchState === 'A') {
            return this.getConnector('DIVERGING');
        } else {
            return this.getConnector('STRAIGHT');
        }
    }

    // ========================================================================
    // SERIALIZATION
    // ========================================================================

    /**
     * Export piece data to JSON format for saving
     * @returns JSON-serializable object
     */
    toJSON(): object {
        return {
            id: this.id,
            catalogId: this.catalogId,
            transform: {
                pos: {
                    x: this.transform.position.x,
                    y: this.transform.position.y,
                    z: this.transform.position.z
                },
                rot: {
                    x: this.transform.rotation.x,
                    y: this.transform.rotation.y,
                    z: this.transform.rotation.z,
                    w: this.transform.rotation.w
                }
            },
            connectors: this.connectors.map(c => ({
                id: c.id,
                localPos: {
                    x: c.localPos.x,
                    y: c.localPos.y,
                    z: c.localPos.z
                },
                localForward: {
                    x: c.localForward.x,
                    y: c.localForward.y,
                    z: c.localForward.z
                },
                nodeId: c.nodeId
            })),
            generatedEdgeIds: this.generatedEdgeIds,
            isSwitch: this.isSwitch,
            switchState: this.switchState
        };
    }

    // ========================================================================
    // UTILITY METHODS
    // ========================================================================

    /**
     * Get the center position of the piece
     * @returns World position of piece center
     */
    getCenter(): Vector3 {
        return this.transform.position.clone();
    }

    /**
     * Get the bounding info for collision detection
     * This is a simple approximation - could be enhanced
     * @returns Object with min/max bounds
     */
    getBounds(): { min: Vector3; max: Vector3 } {
        const halfLength = this.catalogEntry.lengthM / 2;
        const halfWidth = 0.02; // Approximate track width

        return {
            min: new Vector3(
                this.transform.position.x - halfLength,
                this.transform.position.y,
                this.transform.position.z - halfWidth
            ),
            max: new Vector3(
                this.transform.position.x + halfLength,
                this.transform.position.y + 0.01, // Rail height
                this.transform.position.z + halfWidth
            )
        };
    }

    /**
     * Check if a world position is near this piece
     * @param position - World position to check
     * @param tolerance - Distance tolerance in meters
     * @returns True if position is within tolerance
     */
    isNearPosition(position: Vector3, tolerance: number = 0.05): boolean {
        const distance = Vector3.Distance(position, this.transform.position);
        return distance <= (this.catalogEntry.lengthM / 2 + tolerance);
    }

    /**
     * Get debug string representation
     * @returns Debug string
     */
    toString(): string {
        return `TrackPiece[${this.id}] ${this.catalogEntry.name} at (${this.transform.position.x.toFixed(3)}, ${this.transform.position.z.toFixed(3)})`;
    }
}