/**
 * TrackGraph.ts - Graph data structure for track layout
 * 
 * Manages:
 * - Nodes (connection points in 3D space)
 * - Edges (directed track segments between nodes)
 * - Graph queries and validation
 */

import { Vector3 } from '@babylonjs/core/Maths/math.vector';

export interface GraphNode {
    id: string;
    pos: Vector3;
}

export interface CurveDefinition {
    type: 'straight' | 'arc';
    arcRadiusM?: number;
    arcAngleDeg?: number;
}

export interface GraphEdge {
    id: string;
    fromNodeId: string;
    toNodeId: string;
    lengthM: number;
    curve: CurveDefinition;
    pieceId: string; // Which track piece generated this edge
}

/**
 * TrackGraph - manages the network of track connections
 */
export class TrackGraph {
    private nodes: Map<string, GraphNode> = new Map();
    private edges: Map<string, GraphEdge> = new Map();
    private nextNodeId = 0;
    private nextEdgeId = 0;

    /**
     * Add a node to the graph
     */
    addNode(pos: Vector3, id?: string): GraphNode {
        const nodeId = id || `n${this.nextNodeId++}`;
        const node: GraphNode = { id: nodeId, pos: pos.clone() };
        this.nodes.set(nodeId, node);
        return node;
    }

    /**
     * Remove a node from the graph
     */
    removeNode(nodeId: string): void {
        // Remove all edges connected to this node
        const connectedEdges = this.getEdgesConnectedToNode(nodeId);
        connectedEdges.forEach(edge => this.removeEdge(edge.id));

        this.nodes.delete(nodeId);
    }

    /**
     * Get node by ID
     */
    getNode(nodeId: string): GraphNode | undefined {
        return this.nodes.get(nodeId);
    }

    /**
     * Find node at or near a position (within tolerance)
     */
    findNodeAt(pos: Vector3, toleranceM: number = 0.001): GraphNode | undefined {
        for (const node of this.nodes.values()) {
            if (Vector3.Distance(node.pos, pos) < toleranceM) {
                return node;
            }
        }
        return undefined;
    }

    /**
     * Get all nodes
     */
    getAllNodes(): GraphNode[] {
        return Array.from(this.nodes.values());
    }

    /**
     * Add an edge to the graph
     */
    addEdge(
        fromNodeId: string,
        toNodeId: string,
        lengthM: number,
        curve: CurveDefinition,
        pieceId: string,
        id?: string
    ): GraphEdge {
        const edgeId = id || `e${this.nextEdgeId++}`;
        const edge: GraphEdge = {
            id: edgeId,
            fromNodeId,
            toNodeId,
            lengthM,
            curve,
            pieceId
        };
        this.edges.set(edgeId, edge);
        return edge;
    }

    /**
     * Remove an edge from the graph
     */
    removeEdge(edgeId: string): void {
        this.edges.delete(edgeId);
    }

    /**
     * Get edge by ID
     */
    getEdge(edgeId: string): GraphEdge | undefined {
        return this.edges.get(edgeId);
    }

    /**
     * Get all edges
     */
    getAllEdges(): GraphEdge[] {
        return Array.from(this.edges.values());
    }

    /**
     * Get edges connected to a node
     */
    getEdgesConnectedToNode(nodeId: string): GraphEdge[] {
        return this.getAllEdges().filter(
            edge => edge.fromNodeId === nodeId || edge.toNodeId === nodeId
        );
    }

    /**
     * Get edges generated by a specific piece
     */
    getEdgesByPiece(pieceId: string): GraphEdge[] {
        return this.getAllEdges().filter(edge => edge.pieceId === pieceId);
    }

    /**
     * Get outgoing edges from a node
     */
    getOutgoingEdges(nodeId: string): GraphEdge[] {
        return this.getAllEdges().filter(edge => edge.fromNodeId === nodeId);
    }

    /**
     * Get incoming edges to a node
     */
    getIncomingEdges(nodeId: string): GraphEdge[] {
        return this.getAllEdges().filter(edge => edge.toNodeId === nodeId);
    }

    /**
     * Check if two nodes are connected by an edge
     */
    areNodesConnected(fromNodeId: string, toNodeId: string): boolean {
        return this.getAllEdges().some(
            edge => edge.fromNodeId === fromNodeId && edge.toNodeId === toNodeId
        );
    }

    /**
     * Get statistics about the graph
     */
    getStats() {
        return {
            nodeCount: this.nodes.size,
            edgeCount: this.edges.size,
            totalLengthM: this.getAllEdges().reduce((sum, edge) => sum + edge.lengthM, 0)
        };
    }

    /**
     * Clear the entire graph
     */
    clear(): void {
        this.nodes.clear();
        this.edges.clear();
        this.nextNodeId = 0;
        this.nextEdgeId = 0;
    }

    /**
     * Export graph to JSON format (for saving)
     */
    toJSON() {
        return {
            nodes: this.getAllNodes().map(node => ({
                id: node.id,
                pos: { x: node.pos.x, y: node.pos.y, z: node.pos.z }
            })),
            edges: this.getAllEdges().map(edge => ({
                id: edge.id,
                fromNodeId: edge.fromNodeId,
                toNodeId: edge.toNodeId,
                lengthM: edge.lengthM,
                curve: edge.curve,
                pieceId: edge.pieceId
            }))
        };
    }

    /**
     * Import graph from JSON format (for loading)
     */
    fromJSON(data: any): void {
        this.clear();

        // Import nodes
        data.nodes.forEach((nodeData: any) => {
            const pos = new Vector3(nodeData.pos.x, nodeData.pos.y, nodeData.pos.z);
            this.addNode(pos, nodeData.id);
        });

        // Import edges
        data.edges.forEach((edgeData: any) => {
            this.addEdge(
                edgeData.fromNodeId,
                edgeData.toNodeId,
                edgeData.lengthM,
                edgeData.curve,
                edgeData.pieceId,
                edgeData.id
            );
        });

        // Update ID counters
        this.nextNodeId = this.nodes.size;
        this.nextEdgeId = this.edges.size;
    }
}